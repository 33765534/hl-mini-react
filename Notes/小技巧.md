# vue开发小技巧，让效率翻倍

## 使用 computed 函数来计算属性
 在 Vue 3 中，你可以同时使用 v-for 和 v-if 指令，但它们的使用是有顺序的，v-for 必须位于 v-if 之前
 在 Vue 3 中，当你需要在计算属性中过滤数组，并将其显示在模板中时，使用 computed 函数。computed 函数允许你编写复杂的逻辑，从而过滤数组。你也可以使用 computed 函数来计算属性。

computed 函数会监听你传递给它的响应式对象的变化。当这些对象发生变化时，computed 函数会返回新的计算结果。
 computed 使用计算属性过滤数组。
 场景1：
 当过滤数组时，你可以使用 computed 函数来返回一个新的数组，该数组只包含满足条件的元素。
 ```
 <template>
  <div v-for="item in filteredArr" :key="item.id">
    <h3>{{ item.title }}</h3>
  </div>
</template>

<script setup>
import { computed, ref } from "vue";

const arr = ref([
  { id: 1, title: "Title 1" },
  { id: 2, title: "Title 2" },
  { id: 3, title: "Title 3" },
  { id: 4, title: "Title 4" },
  { id: 5, title: "Title 5" },
]);

const filteredArr = computed(() => arr.value.filter((item) => item.id !== 3));
</script>

<style scoped lang="scss"></style>

 ```

场景2：
当我有两个数组，想要根据页面某个属性选择的不同来展示不同的数组时，
可以使用computed函数，通过判断页面选择的不同来返回不同的数组
 ```
 <template>
  <button @click="showArr = !showArr">按钮</button>
  <div v-for="item in filteredArr" :key="item.id">
    <h3>{{ item.title }}</h3>
  </div>
</template>

<script setup>
import { computed, ref } from "vue";

const arr = ref([
  { id: 1, title: "Title 1" },
  { id: 2, title: "Title 2" },
  { id: 3, title: "Title 3" },
  { id: 4, title: "Title 4" },
  { id: 5, title: "Title 5" },
]);

const arr2 = ref([
  { id: 1, title: "Title2 1" },
  { id: 2, title: "Title2 2" },
  { id: 3, title: "Title2 3" },
]);
const showArr = ref(true);

const filteredArr = computed(() => (showArr.value ? arr.value : arr2.value));
</script>

<style scoped lang="scss"></style>

 ```

## 使用结构化赋值
v-for 其实还有另外一种写法，使用结构化赋值，可以减少代码量，提高可读性。
```
<template>
  <div>
    <ul>
      <li v-for="{ id, title } in arr" :key="id">
        {{ id }} - {{ title }}
      </li>
    </ul>
  </div>
</template>

<script setup>
import { ref } from "vue";

const arr = ref([
  { id: 1, title: "Title 1" },
  { id: 2, title: "Title 2" },
    ]);
</script>

<style scoped lang="scss"></style>

```

## vue3 穿透样式不生效？
我们先来看一下代码
父类组件：
```
<template>
  <p>我是父组件</p>
  <Bar />
</template>

<script setup>
import Bar from './Bar.vue'
</script>

<style scoped lang="scss">
p {
  color: red;
}
:deep(.title) {
  color: red;
}
</style>

```

子组件：
```
<template>
  <p>第一个P</p>
  <p class="title">第二个P</p>
  <p>第三个P</p>
</template>

<script setup></script>

<style scoped lang="scss"></style>

```

父类创建了一个穿透样式 .title ，并且template 中分别是p和bar组件，是两个根节点
在页面上生成的效果是：
![Alt text](image.png)

我们写了一个穿透样式，但是没有生效，在整个style会存在一个跟容器，我们父类代码中存在两个根，一个是P一个是Bar

这个根有什么用尼？
实际上是决定我们的 scoped 加在哪个根上，所以当前的demo 穿透样式前缀data-v-7a7a37b1 加在的父类的P标签上,导致穿透样式失效
它为什么没有在 Bar组件是加上data-v-7a7a37b1 因为bar组件也没有根 
解决办法：
只有在 [data-v-7a7a37b1] .title 这样写才能生效

我们给父类最外层加上一个根,或者给Bar 加上一个根 可以用div包裹
两种都可以 我们演示一下 第二种
```
<template>
  <div>
    <p>第一个P</p>
    <p class="title">第二个P</p>
    <p>第三个P</p>
  </div>
</template>

<script setup></script>

<style scoped lang="scss"></style>
```
![Alt text](image-1.png)
